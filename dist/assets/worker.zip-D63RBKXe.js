var J=Object.defineProperty;var K=(g,d,y)=>d in g?J(g,d,{enumerable:!0,configurable:!0,writable:!0,value:y}):g[d]=y;var L=(g,d,y)=>K(g,typeof d!="symbol"?d+"":d,y);(function(){"use strict";function g(o,t,e,i){return new(e||(e=Promise))(function(s,n){function r(h){try{c(i.next(h))}catch(l){n(l)}}function a(h){try{c(i.throw(h))}catch(l){n(l)}}function c(h){var l;h.done?s(h.value):(l=h.value,l instanceof e?l:new e(function(u){u(l)})).then(r,a)}c((i=i.apply(o,[])).next())})}typeof SuppressedError=="function"&&SuppressedError;const d=new Blob([Uint8Array.from([80,75,3,4,10,0,0,8,0,0])]),y=new Blob([Uint8Array.from([80,75,1,2,10,0,10,0,0,8,0,0])]),T=new Blob([Uint8Array.from([0,0,0,0,0,0,0,0,0,0])]),V=new Blob([Uint8Array.from([0,0,0,0,0,0,16,0,0,0])]),U=new TextEncoder;class D{static getCRC32(t){}constructor(){this.clear()}clear(){this._dirRecords=new Map,this._dirRecList=[],this._dirRecFileList=[],this._localFileChunks=[],this._curLocalFileHeaderOffset=0,this._centralDirHeaderChunks=[],this._centralDirHeaderLen=0,this._pathCount=0,this._fileCount=0,this._dataSize=0,this._zippedBlob=null,this._resolvingCRCPromise=null}add(t,e,i,s){if(this._zippedBlob)throw new Error("the AnZip object was already zipped. create a new instance or execute clear() before adding a file.");if(!t)throw new Error("path is empty");if(t=String(t).replace(/\\/g,"/").replace(/^\//,""),/\/{2,}|\\|^\/|^[a-z]+:/i.test(t))throw new Error('invalid path. containing a drive letter, a leading slash, or empty directory name: "'+t+'"');let n,r=0,a=null;if(e!==void 0){if(!/[^/]+$/.test(t))throw new Error('needs a file name: "'+t+'"');if(this.has(t))throw new Error('the path already exists: "'+t+'"');if(s!==void 0){if(typeof s!="number")throw new Error("precalculatedCRC must be a number");n=s}if(e instanceof Blob)a=e,r=e.size,n===void 0&&(n=0);else{if(e instanceof Uint8Array||typeof Buffer=="function"&&e instanceof Buffer)a=e;else if(typeof e=="string")a=U.encode(e);else{if(!(e instanceof ArrayBuffer||e instanceof Array))throw new Error("data must be one of the following types Array, TypedArray, ArrayBuffer, Buffer, string, or Blob.");a=new Uint8Array(e)}n===void 0&&(n=H(a)),r=a.byteLength}}let c=null;i instanceof Date?c=i:i===void 0||i===-1?c=new Date:i>=0&&(c=new Date(i));const h=c?w(c.getFullYear()-1980<<25|c.getMonth()+1<<21|c.getDate()<<16|c.getHours()<<11|c.getMinutes()<<5|c.getSeconds()/2):[0,0,0,0];let l,u,z,b=t.replace(/\/+$/,"").split("/"),f="";for(;b.length;){f+=b.shift();const C=!!(e&&b.length===0);if(f+=C?"":"/",this._dirRecords.has(f))continue;const v=U.encode(f),B=v.length,$=C&&r?w(r):[0,0,0,0],I={offset:this._curLocalFileHeaderOffset,size:r,path:f,pathLength:B,isFile:C};this._dirRecords.set(f,I),this._dirRecList.push(I),C&&this._dirRecFileList.push(I),this._pathCount++,l=Uint8Array.from([].concat(h,C?w(n):[0,0,0,0],$,$,[255&B,B>>8&255,0,0])),u=[d,l,v],this._localFileChunks.push(u);const Y=C?T:V,G=Uint8Array.from(w(this._curLocalFileHeaderOffset));this._centralDirHeaderChunks.push([y,l,Y,G,v]),this._centralDirHeaderLen+=46+B,this._curLocalFileHeaderOffset+=30+B+(C?r:0)}a&&(s===void 0&&a instanceof Blob&&(z=this._resolveBlobCRC(a,l,t)),u.push(a),this._dataSize+=r,this._fileCount++);let S=this._pathCount;return(z||Promise.resolve()).then(()=>S)}_resolveBlobCRC(t,e,i){let s,n;const r=this._resolvingCRCPromise||Promise.resolve(),a=new Promise((h,l)=>{s=h,n=l});this._resolvingCRCPromise=a;let c=!1;return r.finally(()=>{(function(h){return M(h).then(l=>H(new Uint8Array(l)))})(t).then(h=>{new DataView(e.buffer).setUint32(4,h,!0),c=!0}).catch(h=>{throw this.remove(i),new Error(`${h.message}
could not resolve the blob CRC.`)}).finally(()=>{this._resolvingCRCPromise===a&&(this._resolvingCRCPromise=null),c?s():n()})}),a}_checkPending(){if(this._resolvingCRCPromise)throw new Error("the AnZip object is still pending. execute wait() and await the fulfillment of the Promise beforehand.")}_getFileRecord(t){let e;return typeof t=="string"?e=this._dirRecords.get(t):typeof t=="number"&&(e=this._dirRecFileList[t]),e||null}has(t){return!!this._dirRecords.has(t.replace(/\/+$/,""))}size(){return this._dataSize}count(t){return t?this._pathCount:this._fileCount}get(t,e){const i=this._getFileRecord(t);if(i&&i.isFile){if(this._zippedBlob){const{offset:s,size:n,pathLength:r}=i,a=s+r+30;return this._zippedBlob.slice(a,a+n,e)}{const s=this._dirRecList.indexOf(i),n=this._localFileChunks[s][3];return typeof e!="string"||n instanceof Blob&&(!e||n.type===e)?n:new Blob([n],{type:e})}}return null}getPathByIndex(t){var e;return((e=this._dirRecFileList[t])===null||e===void 0?void 0:e.path)||""}remove(t){if(this._zippedBlob)throw new Error(`could not remove the file. the AnZip object is already zipped. ${t}`);const e=this._getFileRecord(t);if(!e||!e.isFile)return!1;const i=this._dirRecList.indexOf(e);this._localFileChunks.splice(i,1)[0],this._centralDirHeaderChunks.splice(i,1)[0];const s=30+e.pathLength+e.size;this._curLocalFileHeaderOffset-=s;const n=46+e.pathLength;this._centralDirHeaderLen-=n;for(let r=i;r<this._centralDirHeaderChunks.length;r++){const a=this._centralDirHeaderChunks[r][3],c=new DataView(a.buffer).getUint32(0,!0);this._centralDirHeaderChunks[r][3]=Uint8Array.from(w(c-s))}return this._pathCount--,this._fileCount--,this._dataSize-=e.size,this._dirRecords.delete(e.path),this._dirRecFileList.splice(this._dirRecFileList.indexOf(e),1),this._dirRecList.splice(this._dirRecList.indexOf(e),1),!0}list(t){const e=[];for(const[i,s]of this._dirRecords)(t||s.isFile)&&e.push({path:s.path,size:s.size,isFile:s.isFile});return e}buffer(){return this.zip().then(t=>M(t))}blob(){return this.zip()}url(){return this.zip().then(t=>URL.createObjectURL(t))}urlSync(){return URL.createObjectURL(this.zipSync())}wait(t){return g(this,void 0,void 0,function*(){for(;this._resolvingCRCPromise&&(yield this._resolvingCRCPromise,t););})}_buildZipBlob(t){return new Blob(t||this._createCurrentBlobParts(),{type:"application/zip"})}_createCurrentBlobParts(){const t=new Uint8Array([].concat([80,75,5,6,0,0,0,0,255&this._pathCount,this._pathCount>>8,255&this._pathCount,this._pathCount>>8],w(this._centralDirHeaderLen),w(this._curLocalFileHeaderOffset),[0,0]));let e=[];return e=e.concat(...this._localFileChunks,...this._centralDirHeaderChunks,t),e}zip(t){return g(this,void 0,void 0,function*(){if(this._zippedBlob)return this._zippedBlob;const e=this._createCurrentBlobParts();yield this._resolvingCRCPromise;const i=this._buildZipBlob(e);return t&&this._close(i),i})}zipSync(t){if(this._zippedBlob)return this._zippedBlob;this._checkPending();const e=this._buildZipBlob(this._createCurrentBlobParts());return t&&this._close(e),e}_close(t){this._zippedBlob=t,this._localFileChunks=[],this._centralDirHeaderChunks=[]}}const E=new Uint32Array(256);for(let o=0;o<256;o++){let t=o;for(let e=0;e<8;e++)t=1&t?3988292384^t>>>1:t>>>1;E[o]=t}function H(o){let t=4294967295;for(let e=0,i=o.length;e<i;e++)t=E[255&(t^o[e])]^t>>>8;return(4294967295^t)>>>0}function M(o){var t;return((t=o.arrayBuffer)===null||t===void 0?void 0:t.call(o))||new Promise(e=>{let i=new FileReader;i.onload=s=>{e(s.target.result)},i.onerror=()=>{throw new Error("could not read it as ArrayBuffer")},i.readAsArrayBuffer(o),i=null})}function w(o){return[255&o,o>>8&255,o>>16&255,o>>24&255]}class W{constructor(){L(this,"_currentFileCount",0);L(this,"_currentZipIndex",0);L(this,"_totalFileCount",0);L(this,"_zipLengthSumList",[]);L(this,"_pathBank",{})}increase(t){return t&&(this._pathBank[t]=[this._zipLengthSumList.length,this._currentFileCount]),this._currentFileCount++,this._totalFileCount++}split(){this._zipLengthSumList.push(this._totalFileCount),this._currentZipIndex++,this._currentFileCount=0}get(t){if(typeof t=="number"){let e=this._zipLengthSumList.findIndex((n,r)=>t<n);e===-1&&(e=this._zipLengthSumList.length);const i=this._zipLengthSumList[e-1]||0,s=t-i;return[e,s]}else{const e=this._pathBank[String(t)];if(e)return e}return null}getZipIndex(){return this._currentZipIndex}getIndex(){return this._totalFileCount}}const R=[];let Z=0;const k=new Map,F=new W;let p=new D;R.push(p);let _=0,m=0,O=!1,P=1024*1024*1024,j=!1,A="",q="";self.onmessage=async o=>{const{data:{action:t,zipSize:e,keepExt:i,outputExt:s,file:n,index:r,path:a,imageType:c},ports:h}=o;switch(t){case"set-config":P=e,j=!!i,A=s||"",q=c||"",self.postMessage({action:"respond-set-config"});break;case"set-port":{const l=h[0];l.onmessage=u=>X(u,l);return}case"squeeze":O=!0,await p.wait(),x("squeeze-zip");break;case"clear":p.clear(),m=0,_=0;break;case"add-filelist":{_>=P&&x("push-filelist-zip");const l=p.add(a,n);await p.wait(),l&&(_+=n.size,m++);let u={action:"push-filelist",size:_,count:m};self.postMessage(u);break}case"squeeze-filelist":await p.wait(),x("squeeze-filelist-zip");break;case"request-image":{const[l,u]=F.get(r),z=R[l],b=u,f=z.get(b,q);if(!f)break;const S=z.getPathByIndex(b);let v={action:"respond-image",url:URL.createObjectURL(f),index:r,path:S,fileId:k.get(r),size:f.size};self.postMessage(v);break}case"delete-image":{let l=!1;try{const[z,b]=F.get(r);R[z].remove(b),l=!0}catch{}const u={action:"respond-delete",index:r,success:l,fileId:k.get(r)};self.postMessage(u);break}}};const X=(o,t)=>{let{data:{blob:e,path:i,fileId:s}}=o;if(O){t.postMessage({fileId:s,canceled:!0});return}i=i.replace(/^\//,""),j||(i=i.replace(/\.(jpe?g|jfif|pjpeg|pjp|gif|png|avif|webp|bmp|apng|ico)$/i,""));const n=2147483647;let r=i+"."+A,a=1;for(;a<=n&&p.has(r);a++){if(a===n)throw new Error(`failed to create valid output path. ${r}`);r=i+"_"+a+"."+A}const c=e.size;_+c>P&&x("push-zip"),_+=c,m++,k.set(Z++,s),F.increase(),p.add(r,e,void 0);let h={action:"add-zip-completed",fileId:s,entireIndex:Z-1,storedPath:r};self.postMessage(h),t.postMessage({fileId:s,renamed:a>=2,outputPath:r})};function x(o){let t;try{const e=p,i=m,s=_;e.zip(!0).then(()=>e.url()).then(n=>(t={url:n,action:o,size:s,count:i},new Promise(r=>setTimeout(r,0)))).then(()=>{self.postMessage(t)}).catch(n=>{})}catch{t={action:o==="squeeze-zip"?"zip-squeeze-error":"zip-error",size:_,count:m},self.postMessage(t)}p=new D,R.push(p),F.split(),m=0,_=0}})();
