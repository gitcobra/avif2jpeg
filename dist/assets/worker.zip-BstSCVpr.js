var J=Object.defineProperty;var K=(z,_,y)=>_ in z?J(z,_,{enumerable:!0,configurable:!0,writable:!0,value:y}):z[_]=y;var L=(z,_,y)=>K(z,typeof _!="symbol"?_+"":_,y);(function(){"use strict";function z(l,t,e,i){return new(e||(e=Promise))(function(r,o){function s(h){try{c(i.next(h))}catch(a){o(a)}}function n(h){try{c(i.throw(h))}catch(a){o(a)}}function c(h){var a;h.done?r(h.value):(a=h.value,a instanceof e?a:new e(function(u){u(a)})).then(s,n)}c((i=i.apply(l,[])).next())})}typeof SuppressedError=="function"&&SuppressedError;const _=new Blob([Uint8Array.from([80,75,3,4,10,0,0,8,0,0])]),y=new Blob([Uint8Array.from([80,75,1,2,10,0,10,0,0,8,0,0])]),T=new Blob([Uint8Array.from([0,0,0,0,0,0,0,0,0,0])]),V=new Blob([Uint8Array.from([0,0,0,0,0,0,16,0,0,0])]),U=new TextEncoder;class D{static getCRC32(t){}constructor(){this.clear()}clear(){this._dirRecords=new Map,this._dirRecList=[],this._dirRecFileList=[],this._localFileChunks=[],this._curLocalFileHeaderOffset=0,this._centralDirHeaderChunks=[],this._centralDirHeaderLen=0,this._pathCount=0,this._fileCount=0,this._dataSize=0,this._zippedBlob=null,this._resolvingCRCPromise=null}add(t,e,i,r){if(this._zippedBlob)throw new Error("the AnZip object was already zipped. create a new instance or execute clear() before adding a file.");if(!t)throw new Error("path is empty");if(t=String(t).replace(/\\/g,"/").replace(/^\//,""),/\/{2,}|\\|^\/|^[a-z]+:/i.test(t))throw new Error('invalid path. containing a drive letter, a leading slash, or empty directory name: "'+t+'"');let o,s=0,n=null;if(e!==void 0){if(!/[^/]+$/.test(t))throw new Error('needs a file name: "'+t+'"');if(this.has(t))throw new Error('the path already exists: "'+t+'"');if(r!==void 0){if(typeof r!="number")throw new Error("precalculatedCRC must be a number");o=r}if(e instanceof Blob)n=e,s=e.size,o===void 0&&(o=0);else{if(e instanceof Uint8Array||typeof Buffer=="function"&&e instanceof Buffer)n=e;else if(typeof e=="string")n=U.encode(e);else{if(!(e instanceof ArrayBuffer||e instanceof Array))throw new Error("data must be one of the following types Array, TypedArray, ArrayBuffer, Buffer, string, or Blob.");n=new Uint8Array(e)}o===void 0&&(o=H(n)),s=n.byteLength}}let c=null;i instanceof Date?c=i:i===void 0||i===-1?c=new Date:i>=0&&(c=new Date(i));const h=c?w(c.getFullYear()-1980<<25|c.getMonth()+1<<21|c.getDate()<<16|c.getHours()<<11|c.getMinutes()<<5|c.getSeconds()/2):[0,0,0,0];let a,u,p,b=t.replace(/\/+$/,"").split("/"),d="";for(;b.length;){d+=b.shift();const C=!!(e&&b.length===0);if(d+=C?"":"/",this._dirRecords.has(d))continue;const v=U.encode(d),B=v.length,$=C&&s?w(s):[0,0,0,0],I={offset:this._curLocalFileHeaderOffset,size:s,path:d,pathLength:B,isFile:C};this._dirRecords.set(d,I),this._dirRecList.push(I),C&&this._dirRecFileList.push(I),this._pathCount++,a=Uint8Array.from([].concat(h,C?w(o):[0,0,0,0],$,$,[255&B,B>>8&255,0,0])),u=[_,a,v],this._localFileChunks.push(u);const Y=C?T:V,G=Uint8Array.from(w(this._curLocalFileHeaderOffset));this._centralDirHeaderChunks.push([y,a,Y,G,v]),this._centralDirHeaderLen+=46+B,this._curLocalFileHeaderOffset+=30+B+(C?s:0)}n&&(r===void 0&&n instanceof Blob&&(p=this._resolveBlobCRC(n,a,t)),u.push(n),this._dataSize+=s,this._fileCount++);let S=this._pathCount;return(p||Promise.resolve()).then(()=>S)}_resolveBlobCRC(t,e,i){let r,o;const s=this._resolvingCRCPromise||Promise.resolve(),n=new Promise((h,a)=>{r=h,o=a});this._resolvingCRCPromise=n;let c=!1;return s.finally(()=>{(function(h){return M(h).then(a=>H(new Uint8Array(a)))})(t).then(h=>{new DataView(e.buffer).setUint32(4,h,!0),c=!0}).catch(h=>{throw this.remove(i),new Error(`${h.message}
could not resolve the blob CRC.`)}).finally(()=>{this._resolvingCRCPromise===n&&(this._resolvingCRCPromise=null),c?r():o()})}),n}_checkPending(){if(this._resolvingCRCPromise)throw new Error("the AnZip object is still pending. execute wait() and await the fulfillment of the Promise beforehand.")}_getFileRecord(t){let e;return typeof t=="string"?e=this._dirRecords.get(t):typeof t=="number"&&(e=this._dirRecFileList[t]),e||null}has(t){return!!this._dirRecords.has(t.replace(/\/+$/,""))}size(){return this._dataSize}count(t){return t?this._pathCount:this._fileCount}get(t,e){const i=this._getFileRecord(t);if(i&&i.isFile){if(this._zippedBlob){const{offset:r,size:o,pathLength:s}=i,n=r+s+30;return this._zippedBlob.slice(n,n+o,e)}{const r=this._dirRecList.indexOf(i),o=this._localFileChunks[r][3];return typeof e!="string"||o instanceof Blob&&(!e||o.type===e)?o:new Blob([o],{type:e})}}return null}getPathByIndex(t){var e;return((e=this._dirRecFileList[t])===null||e===void 0?void 0:e.path)||""}remove(t){if(this._zippedBlob)throw new Error(`could not remove the file. the AnZip object is already zipped. ${t}`);const e=this._getFileRecord(t);if(!e||!e.isFile)return!1;const i=this._dirRecList.indexOf(e);this._localFileChunks.splice(i,1)[0],this._centralDirHeaderChunks.splice(i,1)[0];const r=30+e.pathLength+e.size;this._curLocalFileHeaderOffset-=r;const o=46+e.pathLength;this._centralDirHeaderLen-=o;for(let s=i;s<this._centralDirHeaderChunks.length;s++){const n=this._centralDirHeaderChunks[s][3],c=new DataView(n.buffer).getUint32(0,!0);this._centralDirHeaderChunks[s][3]=Uint8Array.from(w(c-r))}return this._pathCount--,this._fileCount--,this._dataSize-=e.size,this._dirRecords.delete(e.path),this._dirRecFileList.splice(this._dirRecFileList.indexOf(e),1),this._dirRecList.splice(this._dirRecList.indexOf(e),1),!0}list(t){const e=[];for(const[i,r]of this._dirRecords)(t||r.isFile)&&e.push({path:r.path,size:r.size,isFile:r.isFile});return e}buffer(){return this.zip().then(t=>M(t))}blob(){return this.zip()}url(){return this.zip().then(t=>URL.createObjectURL(t))}urlSync(){return URL.createObjectURL(this.zipSync())}wait(t){return z(this,void 0,void 0,function*(){for(;this._resolvingCRCPromise&&(yield this._resolvingCRCPromise,t););})}_buildZipBlob(t){return new Blob(t||this._createCurrentBlobParts(),{type:"application/zip"})}_createCurrentBlobParts(){const t=new Uint8Array([].concat([80,75,5,6,0,0,0,0,255&this._pathCount,this._pathCount>>8,255&this._pathCount,this._pathCount>>8],w(this._centralDirHeaderLen),w(this._curLocalFileHeaderOffset),[0,0]));let e=[];return e=e.concat(...this._localFileChunks,...this._centralDirHeaderChunks,t),e}zip(t){return z(this,void 0,void 0,function*(){if(this._zippedBlob)return this._zippedBlob;const e=this._createCurrentBlobParts();yield this._resolvingCRCPromise;const i=this._buildZipBlob(e);return t&&this._close(i),i})}zipSync(t){if(this._zippedBlob)return this._zippedBlob;this._checkPending();const e=this._buildZipBlob(this._createCurrentBlobParts());return t&&this._close(e),e}_close(t){this._zippedBlob=t,this._localFileChunks=[],this._centralDirHeaderChunks=[]}}const E=new Uint32Array(256);for(let l=0;l<256;l++){let t=l;for(let e=0;e<8;e++)t=1&t?3988292384^t>>>1:t>>>1;E[l]=t}function H(l){let t=4294967295;for(let e=0,i=l.length;e<i;e++)t=E[255&(t^l[e])]^t>>>8;return(4294967295^t)>>>0}function M(l){var t;return((t=l.arrayBuffer)===null||t===void 0?void 0:t.call(l))||new Promise(e=>{let i=new FileReader;i.onload=r=>{e(r.target.result)},i.onerror=()=>{throw new Error("could not read it as ArrayBuffer")},i.readAsArrayBuffer(l),i=null})}function w(l){return[255&l,l>>8&255,l>>16&255,l>>24&255]}class W{constructor(){L(this,"_currentFileCount",0);L(this,"_currentZipIndex",0);L(this,"_totalFileCount",0);L(this,"_zipLengthSumList",[]);L(this,"_pathBank",{})}increase(t){return t&&(this._pathBank[t]=[this._zipLengthSumList.length,this._currentFileCount]),this._currentFileCount++,this._totalFileCount++}split(){this._zipLengthSumList.push(this._totalFileCount),this._currentZipIndex++,this._currentFileCount=0}get(t){if(typeof t=="number"){let e=this._zipLengthSumList.findIndex((o,s)=>t<o);e===-1&&(e=this._zipLengthSumList.length);const i=this._zipLengthSumList[e-1]||0,r=t-i;return[e,r]}else{const e=this._pathBank[String(t)];if(e)return e}return null}getZipIndex(){return this._currentZipIndex}getIndex(){return this._totalFileCount}}const R=[];let Z=0;const k=new Map,F=new W;let f=new D;R.push(f);let g=0,m=0,O=!1,P=1024*1024*1024,j=!1,A="",q="";self.onmessage=async l=>{const{data:{action:t,zipSize:e,keepExt:i,outputExt:r,file:o,index:s,path:n,imageType:c},ports:h}=l;switch(t){case"set-config":P=e,j=!!i,A=r||"",q=c||"",self.postMessage({action:"respond-set-config"});break;case"set-port":{const a=h[0];a.onmessage=u=>X(u,a);return}case"squeeze":O=!0,await f.wait(),x("squeeze-zip");break;case"clear":f.clear(),m=0,g=0;break;case"add-filelist":{g>=P&&x("push-filelist-zip");let a=!1;if(await f.add(n,o).catch(p=>{a=!0}),a){const p={action:"error-push-filelist-zip",path:n};self.postMessage(p);break}g+=o.size,m++;let u={action:"push-filelist",size:g,count:m};self.postMessage(u);break}case"squeeze-filelist":await f.wait(),x("squeeze-filelist-zip");break;case"request-image":{const[a,u]=F.get(s),p=R[a],b=u,d=p.get(b,q);if(!d)break;const S=p.getPathByIndex(b);let v={action:"respond-image",url:URL.createObjectURL(d),index:s,path:S,fileId:k.get(s),size:d.size};self.postMessage(v);break}case"delete-image":{let a=!1;try{const[p,b]=F.get(s);R[p].remove(b),a=!0}catch{}const u={action:"respond-delete",index:s,success:a,fileId:k.get(s)};self.postMessage(u);break}}};const X=(l,t)=>{let{data:{blob:e,path:i,fileId:r,crc:o}}=l;if(O){t.postMessage({fileId:r,canceled:!0});return}i=i.replace(/^\//,""),j||(i=i.replace(/\.(jpe?g|jfif|pjpeg|pjp|gif|png|avif|webp|bmp|apng|ico)$/i,""));const s=2147483647;let n=i+"."+A,c=1;for(;c<=s&&f.has(n);c++){if(c===s)throw new Error(`failed to create valid output path. ${n}`);n=i+"_"+c+"."+A}const h=e.size;g+h>P&&x("push-zip"),g+=h,m++,k.set(Z++,r),F.increase(),f.add(n,e,void 0);let a={action:"add-zip-completed",fileId:r,entireIndex:Z-1,storedPath:n};self.postMessage(a),t.postMessage({fileId:r,renamed:c>=2,outputPath:n})};function x(l){let t;try{const e=f,i=m,r=g;e.zip(!0).then(()=>e.url()).then(o=>(t={url:o,action:l,size:r,count:i},new Promise(s=>setTimeout(s,0)))).then(()=>{self.postMessage(t)}).catch(o=>{})}catch{t={action:l==="squeeze-zip"?"zip-squeeze-error":"zip-error",size:g,count:m},self.postMessage(t)}f=new D,R.push(f),F.split(),m=0,g=0}})();
